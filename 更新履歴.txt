ver_2からの変更点 20200611


PF
graph search()の重心の水平移動
グラフに接続してから安定余裕の判定して、無効なノードにするかどうかを決めてた。
→接続する前に安定余裕の判定をして、無効なノードをそもそもグラフに接続しないように変更。

メモ6/11
pass4次でleg_conしか変更していないし、SGCPは一切使われていない
で、おそらくpass2次で遊脚のxyとzが両方が変更されている。
でおそらくPhamtomXの軌道の補間方法がxy→z
だとすると、
遊脚のzが前回より低くなった時は、xy→zで補間
遊脚のzが前回より高くなった時は、z＋Δz→xy→zで補間しなきゃいけない。
どこかで、この判定をしてるとこがある？
それか、結局pass2次で着地点選択してるから、
pass2次前に高さ変更しなきゃいけんのかもしれん。

遊脚高さ一定にするなら、コマンダーの変更はいらない
だから、
このz＋Δzを重心高さの変更で補わなきゃいけない。

6/12
pass4次脚の水平移動で脚接地点の探索をしないようにしてみる。
そもそも離散化数上下に分ける必要ある？？？？
あとででいい。。

pass2次脚の上下移動を調べる。
マップのブロックの領域をもう少し狭めていい　特にyの長さ

2次のSPLRの可動範囲のところを修正。修正というかわかりやすくした？
だが、そもそもR[]が間違ってるんじゃないか説濃厚

6/15
R[]は一応おｋ
ただし、遊脚高さを-73以上にしたいときは、if文をコメントアウトする必要がある。
PFの脚の上下のエッジで不要な計算を除外した。
・安定余裕を先に計算して、不要なエッジを接続しないようにした。
・安定余裕の外積の順番を入れ替えて、＋の値を出力するようにして、わかりやすくした。
・脚先候補点はソートされているから1つの階層につき1つだけコピーするようにした。
十分に歩行できていることを確認した。
エッジの接続順を、脚↑重心→脚→脚↓の順にしたら1動作1,2秒で爆速になった。十分に歩行もできている。
22 32 43 24 
62 26 32 43 24 22
あとは、重心↑↓をどこに接続するか、
24のときだけ重心↕探索、62のあとは2だけ探索可能、26のあとは3だけ探索可能
重心↕で接続されたノードに関して、
脚状態を、vはそのままでいいけど、kaisouを変更するかどうか、、、
脚状態を親と同じにすると、i_Fがでなくなって、重心を下げるようになる。
脚の上下の探索はできるけど、そのあとの重心の水平移動ができてない？
重心を下げすぎか。
脚状態を全部４にすると、i_Fがどうチャラが頻発。一応動けるけど、あってるかわからん。
多分↑であってると思うがわからん。
階層の高さだけ変えたらどうなるか、、まだ検証していない。
重心の水平移動をもう一度見直す必要があるか。


ver4 0616
探索深さ6までわりとサクサク　挙動も若干変わる。
4次方向移動（脚の水平移動）で脚設置可能点の選択をしないように変更する。 した　特に問題なし。時間はあまり変わらなそう。
4次方向移動（重心の水平移動）で重心の軌道からのずれを先に除外して、横方向のブレを小さくしてみる.

マップの領域を狭く　した　特に問題なし。時間はあまり変わらなそう。

ver5 0616
4次方向移動（重心の水平移動）で重心の軌道からのずれを先に除外して、横方向のブレを小さくしてみる。 した。　現状うまくいってる。
次は、、
どっかでr[]つかってるとこあったからそれを直す。　した。探索範囲は80mmいかにするかな。
で、重心高さ変えて、また歩かせてみる。
重心高さの、上限がちょっと大きいかな。脚が伸びきってる感ある、
脚の上下のgetgraph()あたりはまだよくわかってない。
脚を上げたときに可動域の判定をする。
探索深さ6でもやってみる。エッジ増えたし。
あとはchooseのいらないところ消したりする。
あとは、離散化数元に戻してみてもいい。
論文見るのもあり。
null動作もグラフに含めて、passが決まった後に、null動作は飛ばして実行するようにしてみる。
探索順序は、脚を上げた後に重心移動の方が動く。全脚接地で重心移動はあんま進まない。

ver 6
0619
CCCのポリゴンごとの代表点を決める部分にめちゃくちゃなバグを発見。これはでかい。
（ポリゴン内かつ既定の安定余裕以上の候補点の中で、旋回半径から一番遠い点を代表点にしていた）
一番近い点に修正。
ここの修正によって、ほぼ目標重心軌道上を通るようになった。

ver7 0623
chooseをいろいろやってみたが大差なし。
CCCで半径に一番近い点じゃなくて、許容範囲内で、一番進行方向に進めるやつにしてみる。 微妙
↑だと、安定余裕を確保しつつ、許容半径内に収まる点が少なすぎて、歩行できなくなると思われる。
上をCOしても、許容半径次第でめちゃくちゃ挙動が変わる不思議。

0624
0619で変更した部分の計算式が若干間違っていたので修正。0619だとほぼ横ブレはないが、無駄な動作が多少増える。何かしらに使える可能性はある。
今回のに変更後は、多少の横ブレ50mm程度はあるが、平地の場合、完全なトライポッド歩容を実現している。
おそらく、これで、CCCのアルゴリズムはとりあえずバグはなくなったと思う。
ただ、ロールピッチの回転を入れると、修正箇所は多数あると思われる。
坂道、重心上下含め、途中で止まることがなくなったか調べる。
シーケンス的に探索するとき、重心の移動量が微小なら、スキップしてやってみる。
可動域　振り上げ高さを調整

ver7までが水平移動のデバック作業に近い。
だから、重心の上下移動を含めるとまだ歩行の継続ができていない。

ver8
重心上下でダメになる原因1　PF.cpp getoptimalroute()でdeletenodeしない
重心上下でダメになる原因2  脚の上下で支持脚の探索もしてたところ（なぜかはわからない）計算が悪いのかも
結局7.1と同じように、脚の上下で遊脚のその階層だけの脚接地可能点を探索するようにした。
結果、重心高さを変えながら、移動できるようになった。

ver9_a  下の2番の方法
全部のエッジに対してnull移動ができるようにする。後ででいいか。

重心の高さ方向の移動を少なくする方法。
2通り
１　choose()で高さの変化が小さいものを選択するようにする。、高さに変化がない場合は、実行ノードを1つ先のやつにする。
２　接地時に、重心高さエッジと脚上下エッジの両方を探索して、あとは任せる。2の方が、実装はすぐ終わる。←微妙
0629
重心の上下動の上限と下限の計算を修正。＋脚の可動範囲を調整。
斜度10°の下りに関しては、歩行ができることを確認した。
遊脚の客先と脚設置可能点の接触の判定を追加した。
ただし、胴体および脚の節の部分と脚設置可能点の接触の判定はまだしていない。

ver10
前脚の可動範囲内の脚接地可能点の最高高さを出す、
重心がその高さ＋マージン分となるような値をを目標重心高さ変化量とする。
重心高さ変化量-目標重心高さ変化量>=0かつ差が最小となるようなパスを選択。
>=0がない場合は、単に差が最小のパスを選択。

何か変更したかっていうと正直あんま覚えてないから（メモもしてないし）、たぶん大したことはしてない。

ver11 0709
１.胴体と脚設置可能点の接触の判定を実装する。(実装方法を検討した)
2.ノードの重心高さの評価をする。
その下準備として、以下を行った。
・目標とする重心高さの変更量を導出する関数を、SPLPに作成した。
int Target_delta_comz()
前2脚の可動範囲内で最も高い脚設置可能点を踏むのに最低限必要な、重心高さの変更量を返す。
値が0より大きいときは、その分だけ重心を上げる必要があることを示す。
0が必要最低限の高さにいることを示す。
0未満が下げられる余裕分を示す。
（前脚だけを見た場合のこと、実際は、胴体や遊脚の接触の制約で、下り斜面とかでは、常に負とかもあり得る。）
まだ、評価関数は変更していないが、シミュレーションを見る限り、
1周期を脚を上げて下ろすまでとすると、重心を上げなければならない２、３周期まえの段階で、必要な重心高さの変更量が得られることが分かった。
このことを考えると、よほど地形の制約が厳しくない限り（どのくらいかはしらん）、頻発していた前脚と地形との接触が起きなくなると考えられ、脚の節の接触判定を実装しなくても実機実験できるようにはなると思う。
今後は、この目標値を基準に重心高さの評価をする部分を実装する。

・ノードのメンバ変数に、重心高さの変更量と、目標とする重心高さの変更量を追加。comzとtarget_comz
上の関数は、PFの重心の上下移動のエッジの部分で計算され、comzとtarget_comzはこのエッジでのみ更新される。
また、comzとtarget_comzは1回の探索毎に0で初期化している。
初期化場所は、mainのグラフ探索の直前で、現在のノード情報を渡す前に行っている。

0710
１.胴体と脚設置可能点の接触の判定を実装する
1-1重心の上下移動のときの判定
SPLPにint Collision_judgment_with_the_body()を作成。
接触しないときはゼロ、接触するときは、接触しないようにする重心の上昇量が返り値になる。
PFの重心の上下移動のエッジで使用している。
返り値をintで丸めてるから、1mm低く見積もっているが、まぁBODY_MARGINの設定で調整すればいい。
そもそも、胴体と接触する機会は少ないと思う。
BODY_MARGINはSPLP.hで定義している。

1-2重心の平行移動のときの判定
各ポリゴンで代表点を求める部分（CCC）で一回実装してみたが、例外処理が出てしまう。
重心高さの評価を先にやってしまった方が良さげ。

0713
1-2の続き
各ポリゴンだと計算量が多すぎる？から、
あまり適切ではないけど、代表点が決まった後（最大7つ）に、それぞれの重心位置で判定を行うようにする。
できた。gaitpatternsearch()の重心の平行移動の部分で、ノードを接続した部分で判定。
接触していたら、接続不可ノードにして、上書きするようにする。
femur_jointまでを胴体とみなしているが、femur_jointまでの長さを実際以上のマージンを取った方が、確実にぶつからなくなりそう。
した。SPLP.cppのCollision_judgment_with_the_body()のfem_marginの値で調整可能。


次はノードの評価方法を変更する。
ver_12
0721
ノードの評価方法の変更の準備
PF.cpp chooseの部分をコメント文をつけて整理した。
評価する値の計算まではやってあるから、
あとは、if文でノードの評価を行って、PFのメンバ変数に優先順序ごとに評価値を代入して、chooseは終了。
とりあえずここまでで、ver12は終了。リスポーン地点

ver_13ではchooseの続きと、functionpassfindingの他スレッドとの評価値の比較の部分を変更する。
そして、段差および斜面で、挙動を確認します。
一応できた。
段差130mmも一応上れた。
斜度20°上りは途中で止まってしまったけど、地面の密度を上げれば歩行できそうかなぁ。
あとは、探索の順番も変更する必要がある。実機実験に向けて。
下り130mmで、支持脚高さがおかしい。
支持脚高さがおかしくなるのは、ver_11のときから、だから、
ver12の派生をつくって、その部分のバグ修正をしてもいいが、どうするか。。←解決。0722
もしくは、探索ルールを変えてやるか。
同条件で、トライポッド歩容にあまり収束していないのが気になる。
まぁ、先行研究もしてないっちゃしてなかったけど、
とりあえず、原稿投稿までのスケジュールを組みなおして、優先順位をつけてみる。。

0722
下り段差130mmで、脚設置可能点40mm四方間隔で置いたときは、歩行ができなかったが、
y方向を20mmにした場合は、歩行を続けて、段差を降りきることができた。
あとは、斜度20度の踏破ができれば、一応今のところの目標は達成。

脚接地可能点の密度変えればいけなくもなさそう。
20°はz可動範囲的にきつそう

脚接地可能点を20mmの格子点にしてみた。
上り下りともに20度は無理。
下りは15度行けた。
上りは前より良なってるけど、途中で止まる。
原因として考えられるのは、重心平行移動時の衝突判定を、代表点ごとにやっている部分
↑あまり関係なさそう。
0727
とりあえず、現状で歩行できる条件のシミュレーション動画をとる。
動作数、移動距離とかもまとめておく。
撮ったら、null動作verと、探索ルール変更verをつくってみる。

ver14
ver13のnull動作ver
null動作とは、、、、
ロボットの状態が変化しない動作のこと
今のところ探索ルールを一連の動作のループにしているから、
場合によっては、状態が変化しない動作を実行することがある。
すると、動作数だけ無駄に増えるから、そのようなnull動作は飛ばして、次の探索深さのノードに
遷移するようにして、無駄な動作を省くようにするっていう魂胆。

それに伴って、今まで除外していた同一状態のノードも取れるようにプログラムに変更を加える。

重心軌道のよこずれ150mmの制約を無くした、特に問題なし。

[null動作]の追加と[null飛ばし]の追加
具体的には、PF.cppのそれぞれのエッジの探索で、null(親ノードと同じノード)を接続できるようにした。
ただし、実際に動作を実行するときは、functionpassfinding.cppでnull動作は飛ばすようにして、動作数が増えないようにしている。
これによって、上り15度の斜面を歩行できるようになった。
また、平地においても、割とトライポッド歩容に収束していることが確認できた。
ただし、段差や下りなどでは、脚の平行のエッジにnullをいれると途中で止まったり、脚を4本以上上げたりしてしまう。
null飛ばしをしないと途中で止まる。
ただし，探索ルール等を変更した場合の挙動についてはまだ確認していない．

とりあえずここまで、
次は、可動範囲や探索ルールを変更してやってみる。

ver15 20200803
そのまえに，
１．目標重心高さ変更量を，重心の前後移動のときも考える．←意味なかった
２．目標重心高さを計算する脚設置可能点の領域を，前2脚の可動範囲から，進行方向の前2脚の可動範囲が
内接する長方形内の地形の最大高さに変更する．←単純な不整地なら関係ないからいまはこのまま

探索ルールを何通りか試してみた。
もっともよかったのが，足を下ろした後に重心高さを変更する一連の動作のループの方法
全探索に近いものでは，よくわからんがうまくいかない。
考えられる原因としては、やはり探索深さが小さいため？

ver16 20200820
脛と地形の干渉を考慮する
地形は4角形ポリゴン
脛はカプセルで判定する。
斜面は一枚の平面としてみる。
段差は、鉛直の壁も用意する。
基本的には重心の水平移動の時だけでいい。
地形は、mapのところで定義してみる
斜面は、三次元座標が8点、段差は12点あればいい。
基本的には実機でぶつからないようにするためだから簡易的に。。
0825
地形の三次元座標は実装した。
次は、地形の点群からなる平面と、線分の干渉チェックについて実装する。
実装はグローバル座標系、法線ベクトルは、水平面は(0,0,1)鉛直面は(0,-1,0)斜面は、角度によるが(0,y,z)zは正で確定、sqrt(y^2+z^2)=1となる角度で定義できそう。
線分は膝関節座標と脚先座標。やり方は、ポリゴンを含む平面を貫通しているか。貫通点がポリゴン内か。
貫通していないとき、ポリゴンと線分をyz平面に投影して最短距離を計算。最短距離が、カプセルの半径以下だったら干渉している。
貫通していて、ポリゴン外のとき、同様にポリゴンと線分をyz平面に投影して最短距離を計算。
6脚×3平面＝18通りをチェック。1つでもフラグが立ったらアウト、そうでなければおｋ。

0827
脛干渉チェック
（１）ポリゴンと脛の線分の干渉を実装→完了
（２）線分同士の最短距離を実装してカプセルの干渉を実装→まだ
(1)の実装はできたが、挙動が厳しい。ノードを消してるのが良くない。（これはPFのgaitepetternsartchの重心平行移動エッジの最後の部分で実装してる）
直進しか考えてないから、ぶつからない程度まで重心の移動量を減らす。

鉛直面をもう一つ増やす手もある。

0828
脛干渉チェック
(1)をCCCの各ポリゴンの代表点決めるところに実装。ただし、胴体と地形の判定は、たぶん計算量多すぎてオーバーフローするからCCCには入れられない。
上り斜面以外は良好。だが上り斜面を踏破するには、評価基準を変える必要がありそう。（他には、安定余裕や重心の最低高さ・脚可動範囲などを調整することも考えられる）例えば、最も進行方向成分が大きい着地点ではなく基準位置に近い着地点に脚を置くようにするとか。
特に前脚の遊脚が重心の平行移動時に斜面にぶつかりまくってるから、その前の前脚をおく段階でどうにかするのが賢明。
前脚を前方に置きすぎるときつい。

とりあえず、今はこれで。
(2)の実装を進める。
一応カプセルまで実装できた。
段差はいい感じ。ただ移動量は減少している。

1006
ランダム地形を試す。
ランダム地形とは、
１．既にある地形で脚接地点の粗密を変更する。
２．既にある地形で粗密を変えずに高さをランダムにするなど。


2020/11/09
ver17
・繰り返しシミュレーションができるようにした
・遊脚の平行移動で、null動作を追加した
・重心の平行移動時の、胴体と地形の衝突判定をCO
・その他いろいろ、コメントの追加

202011/16
ver17つづき
(a)多様な不整地のシミュレーション計画のつづき
前回まで
・mainfunctionで(a)用の地形を作成
	-ヘッダーファイルで定数をいじるだけで汎用的な実装になるようにできるだけしている
・シミュレーション回数（動作数）おそらく動作数が1000回程度まで行くと、エラーが出る気がする。原因は、iostreamとかどこかの配列の上限とかかも
・初期位置のランダム範囲をr=300㎜にすると、前方にずれたときに数動作目から歩行ができなくなってると思われるので、r=200mm程度にしてみる。

今回
・3角形状の地形をつくってみる。つくった
・データをまとめるための出力内容を検討する。
できるだけ、シミュレーション後の作業がわかりやすく、少なくなるような実装にしたい。
・可動域制約2パターン

大体ルールはできた。
ルール
・1回のプログラムの実行で合計1000動作まで（なぜか1000以上だとバグる）、または、10回のシミュレーションが終了するまで
・終了条件は、成功：y=1200mmまで到達　失敗：直近10動作以内に同じノードが得られた、or、歩容パターンが見つからず実行できる動作が無かったのいずれか
・安定余裕や脚可動範囲の制約は、実機実験と同様（矩形脚先軌道で、確実にphantomXで軌道生成できるもの）
・ただし、地形が複雑なため、脛の干渉チェックは行わない。
・1つの地形に対して、整地（ホール率0%）から始め、成功回数がゼロになる

lk \
まで、10%ずつホール率を上げていく。
・（今回は）ホールは1辺100mmの正方形とし、ランダムに足場を除外する。

手順
・地形条件を整えて、実行
・実行後、シミュレーションの動画を取る
・終了時、画面のスクリーンショットを撮影
・WPLを適当なところに条件がわかるように保存
・成功回数ゼロまでやったら、WPLをまとめて、成功率やらをまとめる。
・なにか改善方法が思い当ったら、試してみて、同一地形で過去の成功率やらと比較することで、踏破性能を比較できる。
・ただし、1回の実行で現状1000動作までで、取れるデータが少ないので、できれば、その問題を解消してからの方がいろいろと楽。

得るデータ
・動作毎に、出力されたノード情報、探索されたノードの数、探索時間
・プログラム終了時に、成功率、失敗１、失敗２の内訳、実行回数や、平均探索時間、移動距離、1回のプログラム実行にかかった時間などをまとめたやつを出力。

データから考察できること
・ノード：重心の軌跡や枝刈り用のノードの出現頻度など
・探索されたノードの数：親ノードからの分岐がどのエッジのときに、ノードの数が少なくなるかなどの傾向
・探索時間：1ノード当たりの実行時間などがわかる

今後の改善点
・成功時の地形データや、初期位置なども後々ほしい。ほかに重心高さの変更回数など
・データをまとめる方法などを統一する。（グラフの種類や比較対象など）統一してVBAでマクロを組んだりすれば後々楽
・初期位置ランダムに偏りがあるから、後でもう一度確認してみる。
・明らかに、重心水平移動の分岐が少ない。何かしら閾値で除外してる可能性。重心水平移動に関する部分をもう一度確認する。
・重心高さの探索、離散化が等間隔だから、上下の可動範囲内に目標重心高さがあったら、それも離散化の対象にしてみる。
・枝刈り用のノードの出現頻度をまとめる。
・10動作以上の周期で同じ動作を繰り返すことがあったからそこの改善。
↑20201118のゼミまで


ver18
↓20201118以降
(a)多様な不整地のシミュレーション計画のつづき
ゼミの改善案を実行していく予定
あとは、ループの回数の出力がミスってる。

おそらく変更した方がいいこと
・シミュレーション毎に地形の穴の場所がランダムになっているから、ランダムは最初の1回だけにする。→完了202010111
・そして、その地形データは、excelに出力できるようにする。→完了202010111
・また、その出力したexcelファイルを用いて、地形が生成できるようにする．→完了202010111
・30動作まで記録してデッドロックになってないか確認できるようにする→完了202010111
・重心の初期位置については、シミュレーション毎にランダムにする．→完了202010111
・そして、その初期位置はexcelに出力できるようにする．→完了202010111
・こちらも地形データと同様に、excelファイルから、シミュレーション開始時の初期位置が決定できるようにする．→完了202010111
・初期位置のランダム化→完了202010111
・つまり、1回の実行につき1つの地形データが得られ、1回の実行で行われるシミュレーション回数分だけ初期位置データが得られる．
・この二つのエクセルファイルがあれば、同一地形、同一の初期位置で、複数の異なる歩容パターン生成方法を比較でき、それぞれの不整地踏破性能を評価できる．→完了202010111
・あとは1度接地した脚設置可能点の色をかえる→完了20201011
ここまで

ver19
20210113のゼミ以降

2021/01/21
不整地増やしてシミュレーション回す。
ホールのバリエーション
・ランダム→完了
・縦じま→完了
・横じま→完了
・斜めじま→完了
・網目→完了
・格子点（網目の逆）→完了
地形のバリエーション
・ただの斜面→完了
・傾斜が徐々に上がる斜面
・階段→完了
・斜度が徐々に上がる階段
・2等辺三角形→完了
・幾何学的なブロック段差？

出力の修正→完了
シミュレーション条件設定→完了

ver20
不整地のシミュレーションをしながらちょいちょい修正する
条件
・安定余裕、脚可動範囲などはシミュレーションの条件
・斜面が最大傾斜角10,15,20°×方位角0・30・60・90	12通り、下りもやるなら24通り
・段差が高さ100・120・140×奥行き400・500・600		9通り，下りもやるなら18通り
これらを基本となる不整地とし，それぞれに対して，
・ホールのバリエーション（縦じま、横じま、斜めじま，チェック，格子，ランダム０，２０、４０、６０、８０）の10通り
ホールは，1つが100mm^2のブロックとする（足裏面積5個分^2），脚設置可能点は20㎜間隔（足裏面積と同等とする）
それぞれの地形は1回のプログラムの実行で5回シミュレーションを行い，1回のシミュレーションでは200動作まで，
終了条件は，y=1200に到達したら成功，できなかったら（動作数の限界や周期性のあるデッドロック・歩容パターンが見つからない・中断した）失敗
各ランダム地形は，1回のプログラムで1つランダムに決まる．
初期位置はそろえてもいいけど、全部ランダムにしとく。

得るデータは
・成功率
・到達距離の平均・最大・最小
・1動作当たりの探索時間の平均・最大・最小
・重心高さの軌跡
・終了時のシミュレーションの画像
本当は映像も残したいが手間なのでやめる。
基本となる不整地ごとに，
データを列，ホールのバリエーションを行で表を１つにまとめる。本当はグラフとかにした方がいいが手間なのでやめる．
また、1つの表に対して、10個の重心高さの軌跡と終了時のシミュレーション画像が得られる。
重心高さの軌跡は最悪やめておく。
全部やると，420種類の不整地のデータが得らえる．


平行して作業できるように、一時的にキーボード操作をなくしてる
camera.cpp camera_position3()とmain.cppの528行あたり

グラフィック
・脚と関節をちょっと太くした　hexapodgraphic.cppのDrawHexapod()　240行目あたり
・原点を通る直線と，整地と不整地の境界・ゴールの直線の色を変えた。hexapodgraphic.cppのDrawGround()のif文のところ
・目標重心軌道上の脚設置可能点と、ゴール上の脚設置可能点の色を一時的に替えてる。hexapodgraphic.cppのDrawPossibleLegPosi()

ランダムのホール率は，各ブロックがホールになる確率であって，必ずしも不整地上のホールが占める割合を表しているわけではない．
試行回数を重ねて平均を取れば、そのホール率に収束するというだけ。分散等は調べていない。


2023/04/26
長谷川作業開始
main.cppの大規模なリファクタリングを行った．
#defineの嵐 ひどすぎる．目についたものは全てDefine.cppへまとめた
ファイル入出力を行う処理が非常にゴチャついていたのでCommon/FileIOへ
大きなfor文２つの中を大分整理し，コメントアウトされていた文を削除した
目標はmain.cppの中は10行程度にして全てclassの中に処理を収めることである
また，main.cpp以外にもCCCやSPLなんちゃらなどのわかりづらいファイル名を多数変更した

2023/04/47
PassFinding.cppのリファクタリングを行った
非常に難航中．特にクラスが酷い．
多量のpublicな変数によって構成されており，new deleteによる動的配列や
データの謎のポインタ渡しなど危険なエラーが起きそうなものが多く変更に時間がかかっている
ソースコード中のありとあらゆる場所でfstream叩くのやめてくれ
波東さんのコードは秘伝のたれ形式で不必要なコードが多すぎる．
ひとまず現時点で使われていない関数がかなり多数存在するのでこれらを整理していきたい．

2023/04/28
作業した量が多いので一度ファイルのバックアップをとった．
引き続きPassFinding.cppのリファクタリング．
大分どこの処理をしているのかわかりやすくなった．同時にすさまじい量の未使用関数が明らかになった．
GaitPatternSearch関数がグラフを生成しているらしいので，これを読みやすくする．

2023/05/01
本日も前回に引き続きPassFinding.cppのリファクタリング．
GaitPatternSearch関数の名前をsearchGaitPatternとし，内部で呼び出される関数を整理した．
エラーメッセージをcoutする箇所が多いのはいいとして，その内容がやれ「ここにはこないでください」だの
「えっ？」だの何を示しているのかわかりづらいのはいかがなものなのだろうか...
現在PassFinding.cppのpass_transitions_4zi関数の第2引数をvectorに変更．同時に同関数のswitch文をif文へ書き換え作業中．

2023/05/02
前々から気になっていた構造体VECTORのリネームを行った．dxlibにVECTORという全く同じ名前の構造体が存在するため，エラーの危険性が高い．（仮にusing namespace myvector;を#include "dxlib.h"したファイルで行うと死ぬ．）
floatとdoubleの統一を行いたいのだが，SVectorをfloatにするとhexapod.cppで謎のアクセス違反が生じる．
おそらくポインタでのやり取りが悪さをしていると感じる．doubleよりかはfloatでプログラムを統一したかったのだが，ひとまずfloatで更新していこうと思う．
searchGaitPattern関数の脚平行移動のリファクタリングが完了．内容の理解を終えた．
次は重心平行移動か．
